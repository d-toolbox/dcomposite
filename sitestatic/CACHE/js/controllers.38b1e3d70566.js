// Generated by CoffeeScript 1.11.1
(function() {
  var NodeEditorController, SimpleMessageController, TerminalWarningController, TranslateRulesController, TranslationController, app, defaultRuleSetType, version,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  app = angular.module('temba.controllers', ['ui.bootstrap', 'temba.services', 'ngAnimate']);

  version = new Date().getTime();

  defaultRuleSetType = function() {
    if (window.ivr) {
      return 'wait_digit';
    } else if (window.ussd) {
      return 'wait_menu';
    } else {
      return 'wait_message';
    }
  };

  app.controller('RevisionController', [
    '$scope', '$rootScope', '$log', '$timeout', 'Flow', 'Revisions', function($scope, $rootScope, $log, $timeout, Flow, Revisions) {
      $scope.revisions = function() {
        return Revisions.revisions;
      };
      $scope.apply = function() {
        return $scope.applyDefinition(Flow.flow);
      };
      $scope.cancel = function() {
        if (Revisions.original) {
          return $scope.applyDefinition(Revisions.original);
        } else {
          return $scope.hideRevisions();
        }
      };
      $scope.showRevision = function(revision) {
        var j, len, other, ref;
        ref = Revisions.revisions;
        for (j = 0, len = ref.length; j < len; j++) {
          other = ref[j];
          other.selected = false;
        }
        revision.selected = true;
        if (!Revisions.original) {
          Revisions.original = Flow.flow;
        }
        return Revisions.getRevision(revision).then(function() {
          return $scope.showDefinition(Revisions.definition);
        });
      };
      $scope.showDefinition = function(definition, onChange) {
        $rootScope.visibleActivity = false;
        Flow.flow = null;
        jsPlumb.reset();
        return $timeout(function() {
          Flow.flow = definition;
          if (onChange) {
            return onChange();
          }
        }, 0);
      };
      $scope.applyDefinition = function(definition) {
        var action, actionset, j, k, l, len, len1, len2, markDirty, other, ref, ref1, ref2;
        ref = definition.action_sets;
        for (j = 0, len = ref.length; j < len; j++) {
          actionset = ref[j];
          ref1 = actionset.actions;
          for (k = 0, len1 = ref1.length; k < len1; k++) {
            action = ref1[k];
            action.uuid = uuid();
          }
        }
        ref2 = Revisions.revisions;
        for (l = 0, len2 = ref2.length; l < len2; l++) {
          other = ref2[l];
          other.selected = false;
        }
        markDirty = false;
        if (definition.metadata.revision !== Revisions.original.metadata.revision) {
          definition.metadata.saved_on = Revisions.original.metadata.saved_on;
          markDirty = true;
        }
        return $scope.showDefinition(definition, function() {
          $scope.hideRevisions();
          if (markDirty) {
            return Flow.markDirty();
          }
        });
      };
      return $scope.hideRevisions = function() {
        Revisions.original = null;
        $rootScope.visibleActivity = true;
        return $rootScope.showRevisions = false;
      };
    }
  ]);

  app.controller('FlowController', [
    '$scope', '$rootScope', '$timeout', '$log', '$interval', '$upload', 'Flow', 'Plumb', 'DragHelper', 'utils', function($scope, $rootScope, $timeout, $log, $interval, $upload, Flow, Plumb, DragHelper, utils) {
      var showConnectTransferTo, showDialog, showRecentDelay;
      $rootScope.gearLinks = [];
      $rootScope.ivr = window.ivr;
      $rootScope.ussd = window.ussd;
      $rootScope.hasAirtimeService = window.hasAirtimeService;
      $scope.getContactFieldName = function(ruleset) {
        if (!ruleset._contactFieldName) {
          ruleset._contactFieldName = Flow.getContactField(ruleset);
        }
        return ruleset._contactFieldName;
      };
      $scope.getFlowFieldName = function(ruleset) {
        if (!ruleset._flowFieldName) {
          ruleset._flowFieldName = Flow.getFlowField(ruleset);
        }
        return ruleset._flowFieldName;
      };
      $scope.clickGearMenuItem = function(id) {
        var modal;
        if (id === 'default_language') {
          modal = new ConfirmationModal(gettext('Default Language'), gettext('The default language for the flow is used for contacts which have no preferred language. Are you sure you want to set the default language for this flow to') + ' <span class="attn">' + Flow.language.name + "</span>?");
          modal.addClass('warning');
          modal.setListeners({
            onPrimary: function() {
              return $scope.setBaseLanguage(Flow.language);
            }
          });
          modal.show();
        }
        return false;
      };
      $rootScope.activityInterval = 5000;
      $scope.init = function() {
        return Flow.fetch(window.flowId, function() {
          $scope.updateActivity();
          return $scope.flow = Flow.flow;
        });
      };
      showDialog = function(title, body, okButton, hideCancel) {
        var resolveObj;
        if (okButton == null) {
          okButton = 'Okay';
        }
        if (hideCancel == null) {
          hideCancel = true;
        }
        resolveObj = {
          title: function() {
            return title;
          },
          body: function() {
            return body;
          },
          okButton: function() {
            return okButton;
          },
          hideCancel: function() {
            return hideCancel;
          }
        };
        $scope.dialog = utils.openModal("/partials/modal", SimpleMessageController, resolveObj);
        return $scope.dialog;
      };
      showConnectTransferTo = function() {
        var modal;
        modal = new ConfirmationModal(gettext("TransferTo Disconnected"), gettext("No TransferTo account connected. Please first connect your TransferTo account."));
        modal.addClass('airtime-warning');
        modal.setPrimaryButton(gettext("Connect TransferTo Account"));
        modal.setListeners({
          onPrimary: function() {
            return document.location.href = window.connectAirtimeServiceURL;
          }
        });
        modal.show();
      };
      $scope.showRevisionHistory = function() {
        return $scope.$evalAsync(function() {
          return $rootScope.showRevisions = true;
        });
      };
      $scope.setBaseLanguage = function(lang) {
        if (Flow.languages[0].name === gettext('Default')) {
          Flow.languages.splice(0, 1);
        }
        Flow.languages.splice(Flow.languages.indexOf(lang), 1);
        Flow.languages.unshift(lang);
        Flow.flow.base_language = lang.iso_code;
        return $timeout(function() {
          $scope.setLanguage(lang);
          return Flow.markDirty();
        }, 0);
      };
      $scope.onFileSelect = function($files, actionset, action) {
        var file, modal, scope;
        if (window.dragging || !window.mutable) {
          return;
        }
        scope = this;
        if ($files.length > 1) {
          showDialog("Too Many Files", "To upload a sound file, please drag and drop one file for each step.");
          return;
        }
        file = $files[0];
        if (file.type !== 'audio/wav' && file.type !== 'audio/x-wav') {
          showDialog('Wrong File Type', 'Audio files need to in the WAV format. Please choose a WAV file and try again.');
          return;
        }
        if (action._translation_recording) {
          modal = showDialog('Overwrite Recording', 'This step already has a recording, would you like to replace this recording with ' + file.name + '?', 'Overwrite Recording', false);
          modal.result.then(function(value) {
            if (value === 'ok') {
              action._translation_recording = null;
              return scope.onFileSelect($files, actionset, action);
            }
          });
          return;
        }
        action.uploading = true;
        $scope.upload = $upload.upload({
          url: window.uploadURL,
          data: {
            actionset: actionset.uuid,
            action: action.uuid
          },
          file: file
        }).progress(function(evt) {
          $log.debug("percent: " + parseInt(100.0 * evt.loaded / evt.total));
        }).success(function(data, status, headers, config) {
          if (!action.recording) {
            action.recording = {};
          }
          action.recording[Flow.language.iso_code] = data['path'];
          action.uploading = false;
          action.dirty = true;
          Flow.saveAction(actionset, action);
        });
      };
      $scope.scheduleActivityUpdate = function() {
        $timeout(function() {
          return $scope.updateActivity();
        }, $rootScope.activityInterval);
        return $rootScope.activityInterval += 200;
      };
      $scope.setLanguage = function(lang) {
        Flow.setMissingTranslation(false);
        Flow.language = lang;
        $scope.language = lang;
        return Plumb.repaint();
      };
      $scope.updateActivity = function() {
        if (window.simulation) {
          $scope.scheduleActivityUpdate();
          return;
        }
        return $.ajax({
          type: "GET",
          url: activityURL,
          cache: false,
          success: function(data, status, xhr) {
            $rootScope.pending = data.pending;
            if (xhr.status === 200 && data.activity) {
              $rootScope.activity = {
                active: data.activity,
                visited: data.visited
              };
              if (!window.simulation) {
                $rootScope.visibleActivity = $rootScope.activity;
              }
              return $scope.scheduleActivityUpdate();
            }
          },
          error: function(status) {
            console.log("Error:");
            return console.log(status);
          }
        });
      };
      $scope.$watch((function() {
        return Flow.flow;
      }), function(current) {
        $scope.flow = Flow.flow;
        $scope.languages = Flow.languages;
        $scope.language = Flow.language;
        if (current) {
          jsPlumb.bind('connectionDrag', function(connection) {
            return $scope.onConnectorDrag(connection);
          });
          jsPlumb.bind('connectionDragStop', function(connection) {
            return $scope.onConnectorDrop(connection);
          });
          return jsPlumb.bind('beforeDrop', function(sourceId, targetId) {
            return $scope.onBeforeConnectorDrop(sourceId, targetId);
          });
        } else {
          jsPlumb.unbind('connectionDrag');
          return jsPlumb.unbind('connectionDragStop');
        }
      });
      $scope.$watch((function() {
        return $rootScope.visibleActivity;
      }), function() {
        var j, len, node, ref;
        if ($rootScope.visibleActivity) {
          if (Flow.flow) {
            ref = Flow.flow.rule_sets.concat(Flow.flow.action_sets);
            for (j = 0, len = ref.length; j < len; j++) {
              node = ref[j];
              Flow.applyActivity(node, $rootScope.visibleActivity);
            }
          }
        }
      });
      $scope.getSource = function(category) {
        return category.sources[0];
      };
      $scope.onBeforeConnectorDrop = function(props) {
        var errorMessage;
        errorMessage = Flow.getConnectionError(props.sourceId, props.targetId);
        if (errorMessage) {
          $rootScope.ghost.hide();
          $rootScope.ghost = null;
          showDialog('Invalid Connection', errorMessage);
          return false;
        }
        return true;
      };
      $scope.onConnectorDrop = function(connection) {
        var actionset, category, createdNewNode, ghost, msg, ruleset, source, targetId, to;
        $(connection.sourceId).parent().removeClass('reconnecting');
        source = connection.sourceId.split('_');
        createdNewNode = false;
        if ($rootScope.ghost) {
          ghost = $rootScope.ghost;
          targetId = uuid();
          if (!ghost.hasClass('collision')) {
            if (ghost.hasClass('actions')) {
              msg = {};
              msg[Flow.flow.base_language] = '';
              actionset = {
                x: ghost[0].offsetLeft,
                y: ghost[0].offsetTop,
                uuid: targetId,
                actions: [
                  {
                    type: window.ivr ? 'say' : 'reply',
                    msg: msg,
                    uuid: uuid()
                  }
                ]
              };
              $scope.clickAction(actionset, actionset.actions[0], connection.sourceId);
              createdNewNode = true;
            } else {
              category = {};
              category[Flow.flow.base_language] = "All Responses";
              ruleset = {
                x: ghost[0].offsetLeft,
                y: ghost[0].offsetTop,
                uuid: targetId,
                label: "Response " + (Flow.flow.rule_sets.length + 1),
                operand: "@step.value",
                ruleset_type: defaultRuleSetType(),
                rules: [
                  {
                    test: {
                      test: "true",
                      type: "true"
                    },
                    category: category,
                    uuid: uuid()
                  }
                ]
              };
              $scope.clickRuleset(ruleset, connection.sourceId);
              createdNewNode = true;
            }
          }
          $rootScope.ghost.hide();
          $rootScope.ghost = null;
        }
        if (!createdNewNode) {
          to = connection.targetId;
          if (!connection.source) {
            to = null;
          }
        }
        return $timeout(function() {
          Flow.updateDestination(connection.sourceId, to);
          return Flow.markDirty();
        }, 0);
      };
      $scope.onConnectorDrag = function(connection) {
        var scope;
        DragHelper.hide();
        $(connection.sourceId).parent().addClass('reconnecting');
        scope = $rootScope.ussd ? 'rules' : jsPlumb.getSourceScope(connection.sourceId);
        $rootScope.ghost = $('.ghost.' + scope);
        return $timeout(function() {
          return $rootScope.ghost.show();
        }, 0);
      };
      $scope.createFirstAction = function() {
        var actionset, msg;
        msg = {};
        msg[Flow.flow.base_language] = '';
        actionset = {
          x: 100,
          y: 0,
          uuid: uuid(),
          actions: [
            {
              uuid: uuid(),
              type: window.ivr ? 'say' : 'reply',
              msg: msg
            }
          ]
        };
        return this.clickAction(actionset, actionset.actions[0]);
      };
      $scope.createFirstUssd = function() {
        var category, ruleset;
        category = {};
        category[Flow.flow.base_language] = "All Responses";
        ruleset = {
          x: 100,
          y: 0,
          uuid: uuid(),
          label: "Response " + (Flow.flow.rule_sets.length + 1),
          webhook_action: null,
          ruleset_type: defaultRuleSetType(),
          rules: [
            {
              test: {
                test: "true",
                type: "true"
              },
              category: category,
              uuid: uuid()
            }
          ],
          config: {}
        };
        return this.clickRuleset(ruleset);
      };
      $scope.notBaseLanguageFilter = function(lang) {
        return lang.iso_code !== $scope.flow.base_language;
      };
      $scope.translatableRuleFilter = function(rule) {
        return rule.type === 'contains_any';
      };
      $scope.lastActionMissingTranslation = function(actionset) {
        var lastAction;
        lastAction = actionset.actions[actionset.actions.length - 1];
        if (lastAction) {
          return lastAction._missingTranslation;
        }
      };
      $scope.broadcastToStep = function(event, uuid) {
        window.broadcastToNode(uuid);
        return event.stopPropagation();
      };
      $scope.addNote = function(event) {
        return Flow.addNote(event.offsetX, event.offsetY);
      };
      $scope.removeNote = function(note) {
        return Flow.removeNote(note);
      };
      $scope.clickRuleset = function(ruleset, dragSource) {
        var resolveObj;
        if (dragSource == null) {
          dragSource = null;
        }
        if (window.dragging || !window.mutable) {
          return;
        }
        DragHelper.hide();
        if (ruleset.ruleset_type === 'airtime' && !$rootScope.hasAirtimeService) {
          showConnectTransferTo();
          return;
        }
        if (Flow.language && Flow.flow.base_language !== Flow.language.iso_code && !dragSource) {
          resolveObj = {
            languages: function() {
              return {
                from: Flow.flow.base_language,
                to: Flow.language.iso_code
              };
            },
            ruleset: function() {
              return ruleset;
            },
            translation: function() {
              return {};
            }
          };
          if (Flow.flow.flow_type === 'U') {
            resolveObj.translation = function() {
              return {
                from: ruleset.config.ussd_message[Flow.flow.base_language],
                to: ruleset.config.ussd_message[Flow.language.iso_code]
              };
            };
          }
          return $scope.dialog = utils.openModal("/partials/translate_rules", TranslateRulesController, resolveObj);
        } else {
          if (window.ivr) {
            resolveObj = {
              options: function() {
                return {
                  nodeType: 'ivr',
                  ruleset: ruleset,
                  dragSource: dragSource
                };
              },
              scope: $scope
            };
            return $scope.dialog = utils.openModal("/partials/node_editor", NodeEditorController, resolveObj);
          } else {
            resolveObj = {
              options: function() {
                return {
                  nodeType: 'rules',
                  ruleset: ruleset,
                  dragSource: dragSource
                };
              }
            };
            return $scope.dialog = utils.openModal("/partials/node_editor", NodeEditorController, resolveObj);
          }
        }
      };
      $scope.confirmRemoveWebhook = function(event, ruleset) {
        var removeWarning;
        if (window.dragging || !window.mutable) {
          return;
        }
        removeWarning = $(event.target).parent().children('.remove-warning');
        if (removeWarning.is(':visible')) {
          Plumb.repaint();
          Flow.markDirty();
        } else {
          removeWarning.fadeIn();
          $timeout(function() {
            return removeWarning.fadeOut();
          }, 1500);
        }
        return false;
      };
      $scope.confirmRemoveRuleset = function(event, ruleset) {
        var removeWarning;
        if (window.dragging || !window.mutable) {
          return;
        }
        removeWarning = $(event.target).parent().children('.remove-warning');
        if (removeWarning.is(':visible')) {
          Flow.removeRuleset(ruleset);
        } else {
          removeWarning.fadeIn();
          $timeout(function() {
            return removeWarning.fadeOut();
          }, 1500);
        }
        return false;
      };
      $scope.confirmRemoveConnection = function(connection) {
        var modal;
        modal = new ConfirmationModal(gettext('Remove'), gettext('Are you sure you want to remove this connection?'));
        modal.addClass('alert');
        modal.setListeners({
          onPrimary: function() {
            Flow.removeConnection(connection);
            return Flow.markDirty();
          }
        });
        modal.show();
        return false;
      };
      $scope.clickActionSource = function(actionset) {
        var connection, resolveObj, source;
        if (actionset._terminal) {
          resolveObj = {
            actionset: function() {
              return actionset;
            },
            flowController: function() {
              return $scope;
            }
          };
          return $scope.dialog = utils.openModal("/partials/modal", TerminalWarningController, resolveObj);
        } else {
          if (window.mutable) {
            source = $("#" + actionset.uuid + "> .source");
            connection = Plumb.getSourceConnection(source);
            if (connection) {
              return $scope.confirmRemoveConnection(connection);
            } else {
              return $timeout(function() {
                return DragHelper.showSaveResponse($('#' + actionset.uuid + ' .source'));
              }, 0);
            }
          }
        }
      };
      $scope.clickRuleSource = function(category) {
        var connection, source;
        if (window.mutable) {
          source = $("#" + category.sources[0] + "> .source");
          connection = Plumb.getSourceConnection(source);
          if (connection) {
            return $scope.confirmRemoveConnection(connection);
          } else {
            return $timeout(function() {
              return DragHelper.showSendReply($('#' + category.sources[0] + ' .source'));
            }, 0);
          }
        }
      };
      $scope.addAction = function(actionset) {
        var resolveObj;
        if (window.dragging || !window.mutable) {
          return;
        }
        resolveObj = {
          options: function() {
            return {
              nodeType: 'actions',
              actionset: actionset,
              action: {
                type: window.ivr ? 'say' : 'reply',
                uuid: uuid()
              }
            };
          }
        };
        return $scope.dialog = utils.openModal("/partials/node_editor", NodeEditorController, resolveObj);
      };
      $scope.moveActionUp = function(actionset, action) {
        return Flow.moveActionUp(actionset, action);
      };
      $scope.isMoveable = function(action) {
        return Flow.isMoveableAction(action);
      };
      $scope.confirmRemoveAction = function(event, actionset, action) {
        var removeWarning;
        if (window.dragging || !window.mutable) {
          return;
        }
        removeWarning = $(event.target).parent().children('.remove-warning');
        if (removeWarning.is(':visible')) {
          Flow.removeAction(actionset, action);
        } else {
          removeWarning.fadeIn();
          $timeout(function() {
            return removeWarning.fadeOut();
          }, 1500);
        }
        return false;
      };
      $scope.playRecording = function(action_uuid) {
        $log.debug("Play audio: " + action_uuid);
        $('#' + action_uuid + "_audio").each(function() {
          var audio;
          audio = $(this)[0];
          if (!audio.paused) {
            audio.pause();
            return audio.currentTime = 0;
          }
        });
        return $('#' + action_uuid + "_audio")[0].play();
      };
      $scope.clickAction = function(actionset, action, dragSource) {
        var fromText, ref, resolveObj;
        if (dragSource == null) {
          dragSource = null;
        }
        if (window.dragging || !window.mutable) {
          return;
        }
        DragHelper.hide();
        if (Flow.language && Flow.flow.base_language !== Flow.language.iso_code) {
          if ((ref = action.type) === "send" || ref === "reply" || ref === "say") {
            fromText = action.msg[Flow.flow.base_language];
            resolveObj = {
              languages: function() {
                return {
                  from: Flow.flow.base_language,
                  to: Flow.language.iso_code
                };
              },
              translation: function() {
                return {
                  from: fromText,
                  to: action.msg[Flow.language.iso_code]
                };
              }
            };
            $scope.dialog = utils.openModal("/partials/translation_modal", TranslationController, resolveObj);
            $scope.dialog.opened.then(function() {
              return $('textarea').focus();
            });
            return $scope.dialog.result.then(function(translation) {
              action = utils.clone(action);
              if (translation && translation.strip().length > 0) {
                action.msg[Flow.language.iso_code] = translation;
              } else {
                delete action.msg[Flow.language.iso_code];
              }
              return Flow.saveAction(actionset, action);
            }, (function() {
              return $log.info("Modal dismissed at: " + new Date());
            }));
          }
        } else {
          resolveObj = {
            options: function() {
              return {
                nodeType: 'actions',
                actionset: actionset,
                action: action,
                dragSource: dragSource
              };
            }
          };
          return $scope.dialog = utils.openModal("/partials/node_editor", NodeEditorController, resolveObj);
        }
      };
      $scope.mouseMove = function($event) {
        $rootScope.activityInterval = 5000;
        if ($rootScope.ghost) {
          utils.checkCollisions($rootScope.ghost);
          if ($rootScope.ghost.hasClass('collision')) {
            if ($("#flow .drop-hover").length > 0) {
              $rootScope.ghost.hide();
            } else {
              $rootScope.ghost.show();
            }
          }
          $rootScope.ghost.offset({
            left: $event.pageX - ($rootScope.ghost.width() / 2),
            top: $event.pageY
          });
        }
        return false;
      };
      showRecentDelay = null;
      $scope.hideRecentMessages = function() {
        $timeout.cancel(showRecentDelay);
        if (this.category) {
          this.category._showMessages = false;
          this.$parent.ruleset._showMessages = false;
        }
        if (this.action_set) {
          return this.action_set._showMessages = false;
        }
      };
      return $scope.showRecentMessages = function() {
        var hovered;
        hovered = this;
        return showRecentDelay = $timeout(function() {
          var action_set, category, categoryFrom, categoryTo, ruleset;
          if (hovered.action_set) {
            action_set = hovered.action_set;
            action_set._showMessages = true;
            Flow.fetchRecentMessages(action_set.uuid, action_set.destination).then(function(response) {
              return action_set._messages = response.data;
            });
          }
          if (hovered.category) {
            category = hovered.category;
            ruleset = hovered.$parent.ruleset;
            ruleset._showMessages = true;
            category._showMessages = true;
            categoryFrom = category.sources.join();
            categoryTo = category.target;
            return Flow.fetchRecentMessages(ruleset.uuid, categoryTo, categoryFrom).then(function(response) {
              return category._messages = response.data;
            });
          }
        }, 500);
      };
    }
  ]);

  TranslateRulesController = function($scope, $modalInstance, Flow, utils, languages, ruleset, translation) {
    var j, len, ref, rule;
    $scope.translation = translation;
    ruleset = utils.clone(ruleset);
    ref = ruleset.rules;
    for (j = 0, len = ref.length; j < len; j++) {
      rule = ref[j];
      if (rule.category) {
        rule._translation = {
          category: {},
          test: {},
          label: {}
        };
        rule._translation.category['from'] = rule.category[Flow.flow.base_language];
        rule._translation.category['to'] = rule.category[Flow.language.iso_code];
        if (typeof rule.test.test === "object") {
          rule._translation.test['from'] = rule.test.test[Flow.flow.base_language];
          rule._translation.test['to'] = rule.test.test[Flow.language.iso_code];
        }
      }
      if (ruleset.ruleset_type === 'wait_menu' && rule.label) {
        $scope.translation = translation;
        rule._translation.label['from'] = rule.label[Flow.flow.base_language];
        rule._translation.label['to'] = rule.label[Flow.language.iso_code];
      }
    }
    $scope.ruleset = ruleset;
    $scope.languages = languages;
    $scope.language = Flow.language;
    $scope.ok = function() {
      var k, l, len1, len2, ref1, ref2, ref3;
      ref1 = ruleset.rules;
      for (k = 0, len1 = ref1.length; k < len1; k++) {
        rule = ref1[k];
        if (rule.category) {
          if (rule._translation.category.to && rule._translation.category.to.strip().length > 0) {
            rule.category[Flow.language.iso_code] = rule._translation.category.to;
          } else {
            delete rule.category[Flow.language.iso_code];
          }
          if (typeof rule.test.test === "object") {
            if (rule._translation.test.to && rule._translation.test.to.strip().length > 0) {
              rule.test.test[Flow.language.iso_code] = rule._translation.test.to;
            } else {
              delete rule.test.test[Flow.language.iso_code];
            }
          }
        }
      }
      if (Flow.flow.flow_type === 'U') {
        ruleset.config.ussd_message[Flow.language.iso_code] = $scope.translation.to;
      }
      if (ruleset.ruleset_type === 'wait_menu') {
        ref2 = ruleset.rules;
        for (l = 0, len2 = ref2.length; l < len2; l++) {
          rule = ref2[l];
          if (rule._translation.label.to && rule._translation.label.to.strip().length > 0) {
            rule.label[Flow.language.iso_code] = rule._translation.label.to;
          } else {
            if ((ref3 = rule.label) != null) {
              delete ref3[Flow.language.iso_code];
            }
          }
        }
      }
      Flow.replaceRuleset(ruleset);
      return $modalInstance.close("");
    };
    return $scope.cancel = function() {
      return $modalInstance.dismiss("cancel");
    };
  };

  TranslationController = function($scope, $modalInstance, languages, translation) {
    $scope.translation = translation;
    $scope.languages = languages;
    $scope.ok = function(translationText) {
      return $modalInstance.close(translationText);
    };
    return $scope.cancel = function() {
      return $modalInstance.dismiss("cancel");
    };
  };

  NodeEditorController = function($rootScope, $scope, $modalInstance, $timeout, $log, Flow, Plumb, utils, options) {
    var INTERRUPTED_TYPE, action, actionset, airtimeAmountConfig, config, country, countryAirtime, countryCode, countryConfig, flow, formData, found, j, k, l, lang, len, len1, len2, len3, len4, len5, len6, len7, len8, len9, m, minutes, n, num, o, option, p, q, r, randomBuckets, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, rule, ruleset, s, seenOrgCountries, startsFlow, stopWatching, toRemove;
    $scope.flow = Flow.flow;
    $scope.nodeType = options.nodeType;
    $scope.ivr = window.ivr;
    $scope.ussd = window.ussd;
    $scope.options = options;
    $scope.contactFields = Flow.contactFieldSearch;
    $scope.updateContactFields = Flow.updateContactSearch;
    $scope.actionConfigs = Flow.actions;
    $scope.rulesetConfigs = Flow.rulesets;
    $scope.operatorConfigs = Flow.operators;
    $scope.languages = utils.clone(Flow.languages).filter(function(lang) {
      return lang.name !== "Default";
    });
    $scope.channels = Flow.channels;
    formData = {};
    formData.resthook = "";
    if (options.nodeType === 'rules' || options.nodeType === 'ivr') {
      ruleset = options.ruleset;
      formData.previousRules = ruleset.rules;
      formData.groups = [];
      ref = ruleset.rules;
      for (j = 0, len = ref.length; j < len; j++) {
        rule = ref[j];
        if (rule.test.type === 'in_group') {
          formData.groups.push(rule.test.test);
        }
      }
      if (ruleset.ruleset_type === 'random') {
        randomBuckets = [];
        ref1 = ruleset.rules;
        for (k = 0, len1 = ref1.length; k < len1; k++) {
          rule = ref1[k];
          if (rule.test.type === 'between') {
            randomBuckets.push({
              name: rule.category,
              destination: rule.destination,
              _base: rule.category[Flow.flow.base_language]
            });
          }
        }
        formData.randomBuckets = randomBuckets;
        formData.buckets = randomBuckets.length;
      }
      action = {
        type: window.ivr ? 'say' : 'reply',
        uuid: uuid()
      };
      actionset = {
        _switchedFromRule: true,
        x: ruleset.x,
        y: ruleset.y,
        uuid: uuid(),
        actions: [action]
      };
    } else if (options.nodeType === 'actions') {
      actionset = options.actionset;
      action = options.action;
      if (action.type === "lang") {
        found = false;
        ref2 = $scope.languages;
        for (l = 0, len2 = ref2.length; l < len2; l++) {
          lang = ref2[l];
          if (lang.iso_code === action.lang) {
            found = true;
            break;
          }
        }
        if (!found) {
          $scope.languages.push({
            name: action.name,
            iso_code: action.lang
          });
          $scope.languages.sort(function(a, b) {
            if (a.name < b.name) {
              return -1;
            }
            if (a.name > b.name) {
              return 1;
            }
            return 0;
          });
        }
      }
      ruleset = {
        _switchedFromAction: true,
        x: actionset.x,
        y: actionset.y,
        uuid: uuid(),
        label: "Response " + (Flow.flow.rule_sets.length + 1),
        operand: "@step.value",
        ruleset_type: defaultRuleSetType(),
        rules: [
          {
            test: {
              test: "true",
              type: "true"
            },
            category: 'All Responses',
            uuid: uuid()
          }
        ]
      };
      ruleset.rules[0].category = {
        _base: 'All Responses'
      };
      ruleset.rules[0].category[Flow.flow.base_language] = 'All Responses';
    }
    formData.timeoutOptions = [
      {
        value: 1,
        text: '1 minute'
      }, {
        value: 2,
        text: '2 minutes'
      }, {
        value: 3,
        text: '3 minutes'
      }, {
        value: 4,
        text: '4 minutes'
      }, {
        value: 5,
        text: '5 minutes'
      }, {
        value: 10,
        text: '10 minutes'
      }, {
        value: 15,
        text: '15 minutes'
      }, {
        value: 30,
        text: '30 minutes'
      }, {
        value: 60,
        text: '1 hour'
      }, {
        value: 120,
        text: '2 hours'
      }, {
        value: 180,
        text: '3 hours'
      }, {
        value: 360,
        text: '6 hours'
      }, {
        value: 720,
        text: '12 hours'
      }, {
        value: 1080,
        text: '18 hours'
      }, {
        value: 1440,
        text: '1 day'
      }, {
        value: 2880,
        text: '2 days'
      }, {
        value: 4320,
        text: '3 days'
      }, {
        value: 10080,
        text: '1 week'
      }
    ];
    minutes = 5;
    formData.hasTimeout = false;
    ref3 = ruleset.rules;
    for (m = 0, len3 = ref3.length; m < len3; m++) {
      rule = ref3[m];
      if (rule.test.type === 'timeout') {
        minutes = rule.test.minutes;
        formData.hasTimeout = true;
        break;
      }
    }
    formData.timeout = formData.timeoutOptions[0];
    ref4 = formData.timeoutOptions;
    for (n = 0, len4 = ref4.length; n < len4; n++) {
      option = ref4[n];
      if (option.value === minutes) {
        formData.timeout = option;
      }
    }
    formData.webhook_action = 'GET';
    if (ruleset.config) {
      formData.webhook = ruleset.config.webhook;
      formData.webhook_action = ruleset.config.webhook_action;
    }
    formData.rulesetConfig = Flow.getRulesetConfig({
      type: ruleset.ruleset_type
    });
    $scope.updateActionForm = function(config) {
      if (config.type === 'email') {
        if (typeof $scope.action.msg === 'object') {
          if (Flow.flow.base_language in $scope.action.msg) {
            return $scope.action.msg = $scope.action.msg[Flow.flow.base_language];
          } else {
            return $scope.action.msg = '';
          }
        }
      }
    };
    $scope.showFlip = function() {
      return actionset.actions.length < 2;
    };
    INTERRUPTED_TYPE = 'interrupted_status';
    $scope.ruleset = utils.clone(ruleset);
    $scope.removed = [];
    flow = Flow.flow;
    $scope.flowFields = Flow.getFlowFields(ruleset);
    $scope.fieldIndexOptions = [
      {
        text: 'first',
        id: 0
      }, {
        text: 'second',
        id: 1
      }, {
        text: 'third',
        id: 2
      }, {
        text: 'fourth',
        id: 3
      }, {
        text: 'fifth',
        id: 4
      }, {
        text: 'sixth',
        id: 5
      }, {
        text: 'seventh',
        id: 6
      }, {
        text: 'eighth',
        id: 7
      }, {
        text: 'ninth',
        id: 8
      }
    ];
    $scope.fieldDelimiterOptions = [
      {
        text: 'space',
        id: ' '
      }, {
        text: 'plus',
        id: '+'
      }, {
        text: 'period',
        id: '.'
      }
    ];
    formData.flowField = Flow.getFieldSelection($scope.flowFields, $scope.ruleset.operand, true);
    formData.contactField = Flow.getFieldSelection($scope.contactFields, $scope.ruleset.operand, false);
    config = $scope.ruleset.config;
    if (!config) {
      config = {};
    }
    formData.fieldIndex = Flow.getFieldSelection($scope.fieldIndexOptions, config.field_index, true);
    formData.fieldDelimiter = Flow.getFieldSelection($scope.fieldDelimiterOptions, config.field_delimiter, true);
    airtimeAmountConfig = [];
    seenOrgCountries = [];
    ref5 = angular.copy(Flow.channel_countries);
    for (o = 0, len5 = ref5.length; o < len5; o++) {
      country = ref5[o];
      countryAirtime = country;
      countryCode = country.code;
      if (config[countryCode]) {
        countryAirtime.amount = parseFloat(config[countryCode]['amount']);
      } else {
        countryAirtime.amount = 0;
      }
      seenOrgCountries.push(countryCode);
      airtimeAmountConfig.push(countryAirtime);
    }
    for (countryCode in config) {
      countryConfig = config[countryCode];
      if (indexOf.call(seenOrgCountries, countryCode) < 0) {
        airtimeAmountConfig.push(countryConfig);
      }
    }
    formData.airtimeAmountConfig = airtimeAmountConfig;
    if (ruleset.config) {
      formData.flow = ruleset.config.flow;
    } else {
      formData.flow = {};
    }
    $scope.rulesetTypeChanged = function() {
      if ($scope.formData.rulesetConfig.type === "random") {
        if (!formData.buckets) {
          formData.buckets = 2;
        }
        return $scope.updateRandomBuckets();
      }
    };
    $scope.updateRandomBuckets = function() {
      var i, p, ref6, ref7;
      formData = $scope.formData;
      if (!formData.randomBuckets) {
        formData.randomBuckets = [];
      }
      for (i = p = ref6 = formData.randomBuckets.length, ref7 = formData.buckets; p < ref7; i = p += 1) {
        formData.randomBuckets.push({
          _base: "Bucket " + (i + 1)
        });
      }
      return formData.randomBuckets.splice(formData.buckets);
    };
    $scope.hasRules = function() {
      var ref6;
      if ($scope.formData.rulesetConfig) {
        return ref6 = $scope.formData.rulesetConfig.type, indexOf.call(Flow.supportsRules, ref6) >= 0;
      }
    };
    $scope.getFlowsUrl = function(flow) {
      var url;
      url = "/flow/?_format=select2";
      if (Flow.flow.flow_type === 'S') {
        return url + "&flow_type=S";
      }
      if (Flow.flow.flow_type === 'F') {
        return url + "&flow_type=F&flow_type=V";
      }
      if (Flow.flow.flow_type === 'V') {
        return url + "&flow_type=V";
      }
      return url;
    };
    $scope.isPausingRuleset = function() {
      return Flow.isPausingRulesetType($scope.formData.rulesetConfig.type);
    };
    $scope.remove = function(rule) {
      var index;
      $scope.removed.push(rule);
      index = $scope.ruleset.rules.indexOf(rule);
      return $scope.ruleset.rules.splice(index, 1);
    };
    $scope.numericRule = {
      test: {
        type: 'between'
      },
      config: Flow.getOperatorConfig('between')
    };
    toRemove = [];
    ref6 = $scope.ruleset.rules;
    for (p = 0, len6 = ref6.length; p < len6; p++) {
      rule = ref6[p];
      if (!rule.category) {
        toRemove.push(rule);
        continue;
      }
      rule._config = Flow.getOperatorConfig(rule.test.type);
      if ((ref7 = rule.test.type) === 'date_before' || ref7 === 'date_after' || ref7 === 'date_equal') {
        rule.test._base = rule.test.test.slice(15, -1);
      } else if (rule.test.type !== "between" && rule.test.type !== "ward") {
        if (rule.test.test) {
          if (rule._config.localized) {
            rule.test._base = rule.test.test[Flow.flow.base_language];
          } else {
            rule.test = {
              _base: rule.test.test
            };
          }
        }
      }
      rule.category._base = rule.category[Flow.flow.base_language];
    }
    if (window.ivr) {
      $scope.numbers = (function() {
        var q, results;
        results = [];
        for (num = q = 1; q <= 9; num = ++q) {
          results.push({
            number: num,
            uuid: uuid()
          });
        }
        return results;
      })();
      $scope.numbers.push({
        number: 0,
        uuid: uuid()
      });
      ref8 = $scope.ruleset.rules;
      for (q = 0, len7 = ref8.length; q < len7; q++) {
        rule = ref8[q];
        num = parseInt(rule.test._base);
        if (num >= 0 && num <= 9) {
          if (num === 0) {
            num = 10;
          }
          $scope.numbers[num - 1].category = rule.category;
          $scope.numbers[num - 1].uuid = rule.uuid;
          $scope.numbers[num - 1].destination = rule.destination;
        }
      }
    }
    for (r = 0, len8 = toRemove.length; r < len8; r++) {
      rule = toRemove[r];
      $scope.remove(rule);
    }
    $scope.sortableOptions = {
      forcePlaceholderSize: true,
      scroll: false,
      placeholder: "sort-placeholder"
    };
    $scope.updateCategory = function(rule) {
      var categoryName;
      if (!rule.category._autoName) {
        return;
      }
      categoryName = $scope.getDefaultCategory(rule);
      if (rule.category) {
        return rule.category._base = categoryName;
      } else {
        return rule.category = {
          _base: categoryName
        };
      }
    };
    $scope.isVisibleOperator = function(operator) {
      if ($scope.formData.rulesetConfig.type === 'wait_digits') {
        if (!operator.voice) {
          return false;
        }
      }
      return operator.show;
    };
    $scope.isVisibleRulesetType = function(rulesetConfig) {
      var ref9, valid;
      valid = (ref9 = flow.flow_type, indexOf.call(rulesetConfig.filter, ref9) >= 0);
      if ((rulesetConfig.type === 'flow_field' || rulesetConfig.type === 'form_field') && $scope.flowFields.length === 0) {
        return false;
      }
      if (rulesetConfig.type === 'contact_field' && $scope.contactFields.length === 0) {
        return false;
      }
      if (rulesetConfig.type === 'airtime' && !$rootScope.hasAirtimeService) {
        return false;
      }
      return valid;
    };
    $scope.getDefaultCategory = function(rule) {
      var categoryName, days, named, op, words;
      categoryName = '';
      if (rule.test && rule.test._base) {
        categoryName = rule.test._base.strip();
      }
      op = rule._config.type;
      if (op === "between") {
        if (rule.test.min) {
          categoryName = rule.test.min;
        }
        if (rule.test.min && rule.test.max) {
          categoryName += ' - ';
        }
        if (rule.test.max) {
          categoryName += rule.test.max;
        }
      } else if (op === "number") {
        categoryName = "numeric";
      } else if (op === "ward") {
        categoryName = "ward";
      } else if (op === "district") {
        categoryName = "district";
      } else if (op === "state") {
        categoryName = "state";
      } else if (op === "phone") {
        categoryName = "phone";
      } else if (op === "regex") {
        categoryName = "matches";
      } else if (op === "date") {
        categoryName = "is a date";
      } else if (op === "date_before" || op === "date_equal" || op === "date_after") {
        days = rule.test._base;
        if (days) {
          if (days[0] === '-') {
            categoryName = "today " + days;
          } else {
            categoryName = "today +" + days;
          }
          if (days === '1' || days === '-1') {
            categoryName = categoryName + " day";
          } else {
            categoryName = categoryName + " days";
          }
          if (op === 'date_before') {
            categoryName = "< " + categoryName;
          } else if (op === 'date_equal') {
            categoryName = "= " + categoryName;
          } else if (op === 'date_after') {
            categoryName = "> " + categoryName;
          }
        }
      } else if (op === "contains" || op === "contains_any" || op === "starts") {
        words = categoryName.trim().split(/\b/);
        if (words) {
          categoryName = words[0].toUpperCase();
          if (categoryName.length > 1) {
            categoryName = categoryName.charAt(0) + categoryName.substr(1).toLowerCase();
          }
        }
      } else {
        named = Flow.opNames[op];
        if (named) {
          categoryName = named + categoryName;
        }
      }
      return categoryName.substr(0, 36);
    };
    $scope.isRuleComplete = function(rule) {
      var complete;
      complete = true;
      if (!rule.category || !rule.category._base) {
        complete = false;
      } else if (rule._config.operands === 1 && !rule.test._base) {
        complete = false;
      } else if (rule._config.type === 'between' && (!rule.test.min || !rule.test.max)) {
        complete = false;
      } else if (rule._config.type === 'ward' && (!rule.test.state || !rule.test.district)) {
        complete = false;
      }
      return complete;
    };
    stopWatching = $scope.$watch((function() {
      return $scope.ruleset;
    }), function() {
      var complete, len9, ref10, ref9, s;
      complete = true;
      ref9 = $scope.ruleset.rules;
      for (s = 0, len9 = ref9.length; s < len9; s++) {
        rule = ref9[s];
        if ((ref10 = rule._config.type) === 'airtime_status' || ref10 === 'subflow' || ref10 === 'timeout' || ref10 === INTERRUPTED_TYPE) {
          continue;
        }
        complete = complete && $scope.isRuleComplete(rule);
        if (!complete) {
          break;
        }
      }
      if (complete && $scope.ruleset.ruleset_type !== 'wait_menu') {
        return $scope.ruleset.rules.splice($scope.ruleset.rules.length - 1, 0, {
          uuid: uuid(),
          test: {
            type: window.ivr ? "starts" : "contains_any"
          },
          category: {
            _autoName: true,
            _base: ''
          },
          _config: window.ivr ? Flow.getOperatorConfig('starts') : Flow.getOperatorConfig('contains_any')
        });
      }
    }, true);
    $scope.updateRules = function(ruleset, rulesetConfig, splitEditor) {
      var bucket, category, group, i1, idx, interruptedCategory, interruptedDestination, interruptedRuleUuid, j1, len10, len11, len12, len13, len14, len15, len16, len17, len18, len9, min, newRule, new_rule, old_groups, otherCategory, otherDestination, otherRuleUuid, ref10, ref11, ref12, ref13, ref14, ref15, ref16, ref17, ref18, ref19, ref20, ref21, ref9, rules, s, size, t, timeoutCategory, timeoutDestination, timeoutRuleUuid, u, v, validRules, w, x, y, z;
      rules = [];
      if (rulesetConfig.rules) {
        validRules = {};
        ref9 = rulesetConfig.rules;
        for (s = 0, len9 = ref9.length; s < len9; s++) {
          rule = ref9[s];
          validRules[rule.test.type] = true;
        }
        ref10 = ruleset.rules;
        for (t = 0, len10 = ref10.length; t < len10; t++) {
          rule = ref10[t];
          if (validRules[rule.test.type]) {
            rules.push(rule);
          }
        }
        ref11 = rulesetConfig.rules;
        for (u = 0, len11 = ref11.length; u < len11; u++) {
          rule = ref11[u];
          found = false;
          ref12 = ruleset.rules;
          for (v = 0, len12 = ref12.length; v < len12; v++) {
            new_rule = ref12[v];
            if (angular.equals(new_rule.test, rule.test)) {
              found = true;
              break;
            }
          }
          if (!found) {
            newRule = {
              uuid: uuid(),
              test: rule.test,
              category: {}
            };
            newRule.category[Flow.flow.base_language] = rule.name;
            rules.push(newRule);
          }
        }
      }
      if (ruleset.ruleset_type === 'random') {
        rules = [];
        size = 1.0 / $scope.formData.randomBuckets.length;
        min = 0;
        ref13 = $scope.formData.randomBuckets;
        for (idx = w = 0, len13 = ref13.length; w < len13; idx = ++w) {
          bucket = ref13[idx];
          if (!bucket.name) {
            bucket.name = {};
          }
          bucket.name[Flow.flow.base_language] = bucket._base;
          rules.push({
            uuid: uuid(),
            test: {
              type: 'between',
              min: "" + min,
              max: "" + (min + size)
            },
            category: bucket.name,
            destination: bucket.destination
          });
          min += size;
        }
      }
      if (ruleset.ruleset_type === 'group') {
        old_groups = {};
        if (formData.previousRules) {
          ref14 = formData.previousRules;
          for (x = 0, len14 = ref14.length; x < len14; x++) {
            rule = ref14[x];
            if (rule.test.type === 'in_group') {
              if (rule.test.test.uuid) {
                old_groups[rule.test.test.uuid] = rule;
              }
            }
          }
        }
        ref15 = splitEditor.omnibox.selected.groups;
        for (y = 0, len15 = ref15.length; y < len15; y++) {
          group = ref15[y];
          if (typeof group === 'string') {
            group = {
              name: group
            };
          }
          if (group.id && group.id in old_groups) {
            rules.push(old_groups[group.id]);
          } else {
            category = {};
            category[Flow.flow.base_language] = group.name;
            rule = {
              uuid: uuid(),
              test: {
                type: 'in_group',
                test: {
                  name: group.name
                }
              },
              category: category
            };
            if (group.id) {
              rule.test.test['uuid'] = group.id;
            }
            rules.push(rule);
          }
        }
      }
      if (ruleset.ruleset_type === 'wait_digit') {
        ref16 = $scope.numbers;
        for (z = 0, len16 = ref16.length; z < len16; z++) {
          option = ref16[z];
          if (option.category && option.category._base) {
            rule = {
              uuid: option.uuid,
              destination: option.destination,
              category: option.category,
              test: {
                type: 'eq',
                test: option.number
              }
            };
            rule.category[Flow.flow.base_language] = option.category._base;
            rules.push(rule);
          }
        }
      }
      if ($scope.hasRules()) {
        ref17 = ruleset.rules;
        for (i1 = 0, len17 = ref17.length; i1 < len17; i1++) {
          rule = ref17[i1];
          if ((ref18 = rule._config.type) === 'true' || ref18 === 'timeout' || ref18 === INTERRUPTED_TYPE) {
            continue;
          }
          if ((!rule.category || !rule.category._base) && rule._config.type === 'between' && rule.test.min && rule.test.max) {
            rule.category = {
              _base: rule.test.min + " - " + rule.test.max
            };
          }
          if (!rule.category || (rule.category._base.strip().length === 0)) {
            continue;
          }
          rule.test.type = rule._config.type;
          if ((ref19 = rule._config.type) === "date_before" || ref19 === "date_after" || ref19 === "date_equal") {
            rule.test.test = "@(date.today + " + rule.test._base + ")";
          } else {
            if (rule._config.localized) {
              if (!rule.test.test) {
                rule.test.test = {};
              }
              rule.test.test[Flow.flow.base_language] = rule.test._base;
            } else {
              rule.test.test = rule.test._base;
            }
          }
          rule.category[Flow.flow.base_language] = rule.category._base;
          if (rule.category) {
            rules.push(rule);
          }
        }
      }
      otherRuleUuid = uuid();
      otherDestination = null;
      timeoutRuleUuid = uuid();
      timeoutDestination = null;
      timeoutCategory = {};
      timeoutCategory[Flow.flow.base_language] = 'No Response';
      interruptedRuleUuid = uuid();
      interruptedDestination = null;
      interruptedCategory = {};
      interruptedCategory[Flow.flow.base_language] = "Interrupted";
      ref20 = ruleset.rules;
      for (j1 = 0, len18 = ref20.length; j1 < len18; j1++) {
        rule = ref20[j1];
        if (rule._config.type === 'true') {
          otherDestination = rule.destination;
          otherCategory = rule.category;
          otherRuleUuid = rule.uuid;
        } else if (rule._config.type === 'timeout') {
          timeoutDestination = rule.destination;
          timeoutCategory = rule.category;
          timeoutRuleUuid = rule.uuid;
        } else if (rule._config.type === INTERRUPTED_TYPE) {
          interruptedDestination = rule.destination;
          interruptedCategory = rule.category;
          interruptedRuleUuid = rule.uuid;
        }
      }
      if (!otherCategory) {
        otherCategory = {};
      }
      otherCategory[Flow.flow.base_language] = 'Other';
      if (!rulesetConfig.rules && !rulesetConfig.hide_other) {
        rules.push({
          _config: Flow.getOperatorConfig("true"),
          test: {
            test: "true",
            type: "true"
          },
          destination: otherDestination,
          uuid: otherRuleUuid,
          category: otherCategory
        });
      }
      if ($scope.formData.hasTimeout && ruleset.ruleset_type === 'wait_message') {
        rules.push({
          _config: Flow.getOperatorConfig("timeout"),
          test: {
            type: "timeout",
            minutes: $scope.formData.timeout.value
          },
          destination: timeoutDestination,
          uuid: timeoutRuleUuid,
          category: timeoutCategory
        });
      }
      rules = (function() {
        var k1, len19, results;
        results = [];
        for (k1 = 0, len19 = rules.length; k1 < len19; k1++) {
          rule = rules[k1];
          if (Flow.isRuleAllowed($scope.ruleset.ruleset_type, rule.test.type)) {
            results.push(rule);
          }
        }
        return results;
      })();
      if (rules.length === 1) {
        otherCategory[Flow.flow.base_language] = 'All Responses';
      }
      if ((ref21 = ruleset.ruleset_type) === 'wait_menu' || ref21 === 'wait_ussd') {
        rules.push({
          _config: Flow.getOperatorConfig(INTERRUPTED_TYPE),
          test: {
            test: "interrupted",
            type: INTERRUPTED_TYPE
          },
          destination: interruptedDestination,
          uuid: interruptedRuleUuid,
          category: interruptedCategory
        });
      }
      return $scope.ruleset.rules = rules;
    };
    $scope.okRules = function(splitEditor) {
      stopWatching();
      $modalInstance.close("");
      return $timeout(function() {
        var airtimeConfig, amount, connections, contactField, elt, flowField, len10, len9, ref9, rulesetConfig, s, t;
        ruleset = $scope.ruleset;
        if (!ruleset.config) {
          ruleset.config = {};
        }
        formData = $scope.formData;
        rulesetConfig = formData.rulesetConfig;
        contactField = formData.contactField;
        flowField = formData.flowField;
        airtimeAmountConfig = formData.airtimeAmountConfig;
        flow = formData.flow;
        ruleset.ruleset_type = rulesetConfig.type;
        if (rulesetConfig.type === 'subflow') {
          flow = splitEditor.flow.selected[0];
          ruleset.config = {
            flow: {
              name: flow.text,
              uuid: flow.id
            }
          };
        }
        if (rulesetConfig.type === 'random') {
          ruleset.operand = '@(RAND())';
        }
        if (rulesetConfig.type === 'form_field') {
          ruleset.operand = '@flow.' + flowField.id;
          ruleset.config.field_index = $scope.formData.fieldIndex.id;
          ruleset.config.field_delimiter = $scope.formData.fieldDelimiter.id;
        } else if (rulesetConfig.type === 'airtime') {
          airtimeConfig = {};
          for (s = 0, len9 = airtimeAmountConfig.length; s < len9; s++) {
            elt = airtimeAmountConfig[s];
            amount = elt.amount;
            try {
              elt.amount = parseFloat(amount);
            } catch (error) {
              elt.amount = 0;
            }
            airtimeConfig[elt.code] = elt;
          }
          ruleset.config = airtimeConfig;
        } else if (rulesetConfig.type === 'resthook') {
          ruleset.config = {
            'resthook': splitEditor.resthook.selected[0]['id']
          };
        } else if (rulesetConfig.type === 'webhook') {
          ruleset.config = {
            webhook: formData.webhook,
            webhook_action: formData.webhook_action
          };
        } else if (rulesetConfig.type === 'contact_field') {
          ruleset.operand = '@contact.' + contactField.id;
        } else if (rulesetConfig.type === 'flow_field') {
          ruleset.operand = '@flow.' + flowField.id;
        } else if (rulesetConfig.type === 'wait_message') {
          ruleset.operand = '@step.value';
        }
        $scope.updateRules(ruleset, rulesetConfig, splitEditor);
        Plumb.disconnectRules($scope.removed);
        connections = Plumb.getConnectionMap({
          target: actionset.uuid
        });
        if (ruleset._switchedFromAction) {
          Flow.removeActionSet($scope.actionset);
        }
        Flow.replaceRuleset(ruleset, false);
        ref9 = ruleset.rules;
        for (t = 0, len10 = ref9.length; t < len10; t++) {
          rule = ref9[t];
          if (rule.destination && !Flow.isConnectionAllowed(ruleset.uuid + '_' + rule.uuid, rule.destination)) {
            Flow.updateDestination($scope.ruleset.uuid + '_' + rule.uuid, null);
          }
        }
        if (ruleset._switchedFromAction) {
          $timeout(function() {
            var results, ruleset_uuid, source;
            ruleset_uuid = ruleset.uuid;
            results = [];
            for (source in connections) {
              if (Flow.isConnectionAllowed(source, ruleset_uuid)) {
                results.push(Flow.updateDestination(source, ruleset_uuid));
              } else {
                results.push(void 0);
              }
            }
            return results;
          }, 0);
        }
        if ($scope.options.dragSource) {
          if (Flow.isConnectionAllowed($scope.options.dragSource, ruleset.uuid)) {
            Flow.updateDestination($scope.options.dragSource, ruleset.uuid);
          }
        }
        return Flow.markDirty();
      }, 0);
    };
    $scope.cancel = function() {
      stopWatching();
      return $modalInstance.dismiss("cancel");
    };
    $scope.action = utils.clone(action);
    $scope.actionset = actionset;
    $scope.flowId = window.flowId;
    startsFlow = false;
    ref9 = actionset.actions;
    for (s = 0, len9 = ref9.length; s < len9; s++) {
      action = ref9[s];
      if (action.type === 'flow' && $scope.action.uuid !== action.uuid) {
        startsFlow = true;
        break;
      }
    }
    $scope.base_language = Flow.flow.base_language;
    if (!$scope.action.lang) {
      $scope.action.lang = Flow.base_language;
    }
    $scope.methods = ['GET', 'POST'];
    if (!$scope.action.action) {
      $scope.action.action = 'GET';
    }
    $scope.config = Flow.getActionConfig({
      type: $scope.action.type
    });
    $scope.validActionFilter = function(action) {
      var ref10, valid;
      valid = false;
      if (action.filter) {
        valid = (ref10 = flow.flow_type, indexOf.call(action.filter, ref10) >= 0);
      }
      if (startsFlow && action.type === 'flow') {
        return false;
      }
      return valid;
    };
    $scope.savePlay = function() {
      $scope.action.type = 'play';
      Flow.saveAction(actionset, $scope.action);
      return $modalInstance.close();
    };
    $scope.saveMessage = function(message, type) {
      if (type == null) {
        type = 'reply';
      }
      if (typeof $scope.action.msg !== "object") {
        $scope.action.msg = {};
      }
      $scope.action.msg[$scope.base_language] = message;
      $scope.action.type = type;
      Flow.saveAction(actionset, $scope.action);
      return $modalInstance.close();
    };
    $scope.saveSend = function(omnibox, message) {
      var contact, contacts, group, groups, len10, len11, ref10, ref11, t, u;
      groups = [];
      ref10 = omnibox.groups;
      for (t = 0, len10 = ref10.length; t < len10; t++) {
        group = ref10[t];
        groups.push({
          uuid: group.id,
          name: group.name
        });
      }
      $scope.action.groups = groups;
      contacts = [];
      ref11 = omnibox.contacts;
      for (u = 0, len11 = ref11.length; u < len11; u++) {
        contact = ref11[u];
        contacts.push({
          uuid: contact.id,
          name: contact.name
        });
      }
      $scope.action.contacts = contacts;
      $scope.action.variables = omnibox.variables;
      $scope.action.type = 'send';
      if (typeof $scope.action.msg !== "object") {
        $scope.action.msg = {};
      }
      $scope.action.msg[$scope.base_language] = message;
      Flow.saveAction(actionset, $scope.action);
      return $modalInstance.close();
    };
    $scope.saveLabels = function(msgLabels) {
      var label, labels, len10, len11, msgLabel, ref10, t, u;
      labels = [];
      for (t = 0, len10 = msgLabels.length; t < len10; t++) {
        msgLabel = msgLabels[t];
        found = false;
        ref10 = Flow.labels;
        for (u = 0, len11 = ref10.length; u < len11; u++) {
          label = ref10[u];
          if (label.id === msgLabel) {
            found = true;
            labels.push({
              uuid: label.id,
              name: label.text
            });
          }
        }
        if (!found) {
          labels.push({
            uuid: msgLabel.id,
            name: msgLabel.text
          });
        }
      }
      $scope.action.labels = labels;
      $scope.action.type = 'add_label';
      Flow.saveAction(actionset, $scope.action);
      return $modalInstance.close();
    };
    $scope.saveGroups = function(actionType, omnibox, allGroups) {
      var group, groups, len10, len11, ref10, ref11, t, u, variable;
      $scope.action.type = actionType;
      groups = [];
      if (!allGroups) {
        ref10 = omnibox.groups;
        for (t = 0, len10 = ref10.length; t < len10; t++) {
          group = ref10[t];
          if (group.id && group.name) {
            groups.push({
              uuid: group.id,
              name: group.name
            });
          } else {
            groups.push(group);
          }
        }
      }
      $scope.action.msg = void 0;
      $scope.action.groups = groups;
      if (!allGroups) {
        ref11 = omnibox.variables;
        for (u = 0, len11 = ref11.length; u < len11; u++) {
          variable = ref11[u];
          $scope.action.groups.push(variable.id);
        }
      }
      Flow.saveAction(actionset, $scope.action);
      return $modalInstance.close();
    };
    $scope.saveUpdateContact = function(field, value) {
      if (field.id.indexOf('[_NEW_]') === 0 && field.text.indexOf("Add new variable:") === 0) {
        field.text = field.text.slice(18);
        field.id = field.id.slice(7);
        field.id = field.id.toLowerCase().replace(/[^0-9a-z]+/gi, ' ').strip().replace(/[^0-9a-z]+/gi, '_');
        Flow.contactFieldSearch.push({
          id: field.id,
          text: field.text
        });
        Flow.updateContactSearch.push({
          id: field.id,
          text: field.text
        });
      }
      $scope.action.type = 'save';
      $scope.action.field = field.id;
      $scope.action.label = field.text;
      $scope.action.value = value;
      Flow.saveAction(actionset, $scope.action);
      return $modalInstance.close();
    };
    $scope.saveWebhook = function(method, url) {
      $scope.action.type = 'api';
      $scope.action.action = method;
      $scope.action.webhook = url;
      Flow.saveAction(actionset, $scope.action);
      return $modalInstance.close();
    };
    $scope.saveEmail = function(addresses) {
      var address, len10, t, to;
      to = [];
      for (t = 0, len10 = addresses.length; t < len10; t++) {
        address = addresses[t];
        to.push(address.text);
      }
      $scope.action.emails = to;
      $scope.action.type = 'email';
      Flow.saveAction(actionset, $scope.action);
      return $modalInstance.close();
    };
    $scope.saveStartFlow = function(flow, omnibox) {
      var contact, contacts, group, groups, len10, len11, ref10, ref11, t, u;
      if (omnibox) {
        $scope.action.type = 'trigger-flow';
        groups = [];
        ref10 = omnibox.groups;
        for (t = 0, len10 = ref10.length; t < len10; t++) {
          group = ref10[t];
          groups.push({
            uuid: group.id,
            name: group.name
          });
        }
        $scope.action.groups = groups;
        contacts = [];
        ref11 = omnibox.contacts;
        for (u = 0, len11 = ref11.length; u < len11; u++) {
          contact = ref11[u];
          contacts.push({
            uuid: contact.id,
            name: contact.name
          });
        }
        $scope.action.contacts = contacts;
        $scope.action.variables = omnibox.variables;
      } else {
        $scope.action.type = 'flow';
      }
      flow = flow[0];
      $scope.action.flow = {
        uuid: flow.id,
        name: flow.text
      };
      Flow.saveAction(actionset, $scope.action);
      return $modalInstance.close();
    };
    $scope.saveLanguage = function() {
      var len10, ref10, t;
      $scope.action.type = 'lang';
      ref10 = Flow.languages;
      for (t = 0, len10 = ref10.length; t < len10; t++) {
        lang = ref10[t];
        if (lang.iso_code === $scope.action.lang) {
          $scope.action.name = lang.name;
          break;
        }
      }
      Flow.saveAction(actionset, $scope.action);
      return $modalInstance.close();
    };
    $scope.saveChannel = function() {
      var chan, definition, len10, ref10, t;
      definition = {
        type: 'channel',
        channel: $scope.action.channel,
        uuid: $scope.action.uuid
      };
      ref10 = Flow.channels;
      for (t = 0, len10 = ref10.length; t < len10; t++) {
        chan = ref10[t];
        if (chan.uuid === $scope.action.channel) {
          definition['name'] = chan.name;
        }
      }
      Flow.saveAction(actionset, definition);
      return $modalInstance.close();
    };
    $scope.ok = function() {
      var connections;
      $timeout(function() {
        $('.submit').click();
        if (options.dragSource) {
          return Flow.updateDestination(options.dragSource, actionset.uuid);
        }
      }, 0);
      if (actionset._switchedFromRule) {
        connections = Plumb.getConnectionMap({
          target: $scope.ruleset.uuid
        });
        Flow.removeRuleset($scope.ruleset);
        return $timeout(function() {
          var results, source;
          results = [];
          for (source in connections) {
            if (source.split('_').length > 1) {
              results.push(Flow.updateDestination(source, actionset.uuid));
            } else {
              results.push(Flow.updateDestination(source, null));
            }
          }
          return results;
        }, 0);
      }
    };
    $scope.cancel = function() {
      return $modalInstance.dismiss("cancel");
    };
    return $scope.formData = formData;
  };

  SimpleMessageController = function($scope, $modalInstance, $log, title, body, okButton, hideCancel) {
    if (hideCancel == null) {
      hideCancel = true;
    }
    $scope.title = title;
    $scope.body = body;
    $scope.okButton = okButton;
    $scope.hideCancel = hideCancel;
    $scope.ok = function() {
      return $modalInstance.close("ok");
    };
    $scope.cancel = function() {
      return $modalInstance.close("cancel");
    };
  };

  TerminalWarningController = function($scope, $modalInstance, $log, actionset, flowController) {
    var action, j, len, ref, startsFlow;
    $scope.title = "End of Flow";
    $scope.body = "You must first add a response to this branch in order to extend it.";
    $scope.okButton = "Add Response";
    startsFlow = false;
    ref = actionset.actions;
    for (j = 0, len = ref.length; j < len; j++) {
      action = ref[j];
      if (action.type === 'flow') {
        startsFlow = true;
        break;
      }
    }
    if (startsFlow) {
      $scope.body = "Once another flow is started, this flow can no longer continue. To extend this flow, remove any actions that start another flow.";
      $scope.okButton = "Ok";
    }
    $scope.ok = function() {
      $modalInstance.close("ok");
      if (!startsFlow) {
        return flowController.addAction(actionset);
      }
    };
    return $scope.cancel = function() {
      return $modalInstance.dismiss("cancel");
    };
  };

}).call(this);
